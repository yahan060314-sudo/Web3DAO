
"""
HKU Web3 Quant Hackathon — Evaluation Metrics
---------------------------------------------
Implements:
- Portfolio Return
- Sharpe Ratio  (mean portfolio return / std of portfolio returns)
- Sortino Ratio (mean portfolio return / std of negative portfolio returns)  # per brief
- Calmar Ratio  (mean portfolio return / |Max Drawdown|)
- Composite Score = 0.4*Sortino + 0.3*Sharpe + 0.3*Calmar

Assumptions (align with the brief):
- Returns are simple period-to-period portfolio returns (e.g., 1-minute, 5-minute, or daily).
- Mean return is the arithmetic average of those period returns.
- "Std of negative returns" means sample standard deviation computed on returns < 0 only.
- Max Drawdown is computed from the equity curve as the largest peak-to-trough percentage loss.
- No annualization is applied (the brief's formulas are un-annualized).

You can pass either an equity series or a returns series.
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Dict, Literal
import numpy as np
import pandas as pd


def _to_returns(
    series: pd.Series, 
    input_type: Literal["equity","returns"]="equity"
) -> pd.Series:
    """Convert equity series to simple returns if needed; clean NaNs."""
    s = series.astype(float).copy()
    if input_type == "equity":
        ret = s.pct_change().replace([np.inf, -np.inf], np.nan).dropna()
    elif input_type == "returns":
        ret = s.replace([np.inf, -np.inf], np.nan).dropna()
    else:
        raise ValueError("input_type must be 'equity' or 'returns'")
    return ret


def _to_equity(
    series: pd.Series,
    input_type: Literal["equity","returns"]="equity",
    init_equity: float = 1.0
) -> pd.Series:
    """Convert returns series to equity curve if needed."""
    s = series.astype(float).copy()
    if input_type == "equity":
        eq = s
    else:
        eq = (1 + s).cumprod() * float(init_equity)
    return eq


def portfolio_return(
    equity: pd.Series
) -> float:
    """(Final - Initial) / Initial"""
    if len(equity) < 2:
        return 0.0
    initial = float(equity.iloc[0])
    final = float(equity.iloc[-1])
    if initial == 0:
        return np.nan
    return (final - initial) / initial


def max_drawdown(
    equity: pd.Series
) -> float:
    """Return Max Drawdown as a positive fraction (e.g., 0.25 for -25%)."""
    eq = equity.astype(float)
    running_max = eq.cummax()
    drawdown = (eq - running_max) / running_max
    return abs(drawdown.min()) if len(eq) else 0.0


def sharpe_ratio(returns: pd.Series) -> float:
    """Sharpe = mean(returns) / std(returns). If zero std, return 0."""
    mu = returns.mean()
    sigma = returns.std(ddof=1)
    return float(mu / sigma) if sigma and not np.isclose(sigma, 0.0) else 0.0


def sortino_ratio(returns: pd.Series) -> float:
    """Sortino = mean(returns) / std(negative_returns). If no negatives, return large number."""
    mu = returns.mean()
    neg = returns[returns < 0]
    if len(neg) == 0:
        # No downside volatility → define Sortino as +inf; cap to a big number to keep scoring finite.
        return float("inf")
    sigma_d = neg.std(ddof=1)
    return float(mu / sigma_d) if sigma_d and not np.isclose(sigma_d, 0.0) else 0.0


def calmar_ratio(returns: pd.Series, equity: Optional[pd.Series]=None) -> float:
    """Calmar = mean(returns) / |Max Drawdown|. If MDD=0, return +inf."""
    mu = returns.mean()
    if equity is None:
        equity = (1 + returns).cumprod()
    mdd = max_drawdown(equity)
    if mdd == 0 or np.isclose(mdd, 0.0):
        return float("inf")
    return float(mu / mdd)


def evaluate_metrics(
    series: pd.Series,
    input_type: Literal["equity","returns"]="equity",
    init_equity: float = 1.0
) -> Dict[str, float]:
    """
    Compute all metrics and the composite score used for ranking:
      Composite = 0.4*Sortino + 0.3*Sharpe + 0.3*Calmar
    """
    returns = _to_returns(series, input_type=input_type)
    equity = _to_equity(series, input_type=input_type, init_equity=init_equity)

    # Portfolio Return over the full window
    port_ret = portfolio_return(equity)

    # Risk ratios
    sh = sharpe_ratio(returns)
    so = sortino_ratio(returns)
    ca = calmar_ratio(returns, equity=equity)

    # Composite (finite-safe): treat inf as a large cap for scoring consistency
    def _finite(x, cap=1e6):
        if np.isinf(x):
            return cap * np.sign(x)
        if np.isnan(x):
            return 0.0
        return float(x)

    composite = 0.4*_finite(so) + 0.3*_finite(sh) + 0.3*_finite(ca)

    return {
        "portfolio_return": float(port_ret),
        "sharpe": float(sh),
        "sortino": float(so),
        "calmar": float(ca),
        "composite_score": float(composite),
        "max_drawdown": float(max_drawdown(equity)),
        "mean_return": float(returns.mean() if len(returns) else 0.0),
        "std_return": float(returns.std(ddof=1) if len(returns) > 1 else 0.0),
        "std_negative_return": float(returns[returns<0].std(ddof=1) if (returns<0).any() else 0.0),
    }


# --- CLI-style helper for quick use on CSV logs ----------------------------

def load_series_from_csv(
    path: str,
    column: str,
    parse_dates: bool = True
) -> pd.Series:
    """
    Load a time series column from CSV.
    - `column` can be 'equity' or 'returns' (or any column name you choose).
    - Assumes CSV has either an index-like datetime column or a 'timestamp' column.
    """
    df = pd.read_csv(path)
    if parse_dates:
        ts_col = None
        for cand in ("timestamp", "time", "datetime", "date"):
            if cand in df.columns:
                ts_col = cand
                break
        if ts_col is not None:
            df[ts_col] = pd.to_datetime(df[ts_col])
            df = df.sort_values(ts_col).set_index(ts_col)
    if column not in df.columns:
        raise ValueError(f"Column '{column}' not found in CSV.")
    return df[column].astype(float)


if __name__ == "__main__":
    import argparse
    p = argparse.ArgumentParser(description="Evaluate Hackathon Metrics from CSV")
    p.add_argument("--csv", required=True, help="Path to CSV containing equity or returns")
    p.add_argument("--column", required=True, help="Name of the column to read")
    p.add_argument("--input_type", choices=["equity","returns"], default="equity")
    args = p.parse_args()

    s = load_series_from_csv(args.csv, args.column)
    metrics = evaluate_metrics(s, input_type=args.input_type)
    for k, v in metrics.items():
        print(f"{k}: {v:.6f}")
